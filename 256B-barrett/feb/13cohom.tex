% !TEX root = ../notes.tex

\documentclass[../notes.tex]{subfiles}

\begin{document}

\section{February 13}

We now switch gears and talk about cohomology. Notably, this is not the usual algebraic topology version of cohomology from the topology on our scheme because the Zariski topology on a scheme is so terrible.

\subsection{Some Starting Remarks}
Fix a scheme $X$ and an abelian sheaf $\mc F$ on $X$. In other words, $\mc F$ is a sheaf valued in an abelian category (though we personally will only request that $\mc F$ have sections which are modules). Later, we might ask for $\mc F$ to be an $\mathcal O_X$-module.

Roughly speaking, computing cohomology is about computing derived functors. Notably, it will turn out that all relevant categories have enough injectives, so we will be able to build an injective resolution
\[0\to\mc F\to\mc I^1\to\mc I^2\to\mc I^2\to\cdots.\]
Now, $H^\bullet(X,\mc F)$ is intended to be the right-derived functor of $\Gamma(X,-)$, so we will want to take global sections to get a complex
\[0\stackrel{d^{-1}}\to\Gamma(X,\mc I^1)\stackrel{d^0}\to\Gamma(X,\mc I^2)\stackrel{d^1}\to\cdots,\]
which is no longer exact. It then turns out by derived functor magic that we can compute cohomology from these groups. Namely, by definition, we will take
\[H^i(X,\mc F)\coloneqq\frac{\ker d^i}{\im d^{i-1}},\]
which turns out to be exactly the cohomology groups we desire.
\begin{remark}
	The above recipe will work fine for any ``Grothendieck topology,'' such as the \'etale cohomology. We won't see that in this class, but it is a useful general machine.
\end{remark}
\begin{remark}
	Classically, cohomology was computed using more general ``acyclic'' resolutions (most notably for \v{C}ech cohomology), but it turns out that injective resolutions are better-behaved for our abstract arguments. Nonetheless, we will see these acyclic resolutions in this class because they are useful; in particular, we will be building resolutions using flasque sheaves in this class.
\end{remark}

\end{document}